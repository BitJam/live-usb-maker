#!/bin/bash

ME=${0##*/}
MY_DIR=$(dirname "$(readlink -f $0)")

#== BEGIN_CONFIG

    ISO_FILE_SPEC="*.iso"
      SEARCH_DIRS="%USER_HOME% /media /root"
     SEARCH_DEPTH=4
        MAX_FILES=20
     MIN_ISO_SIZE="180M"

          MBR_GPT="msdos"
             SIZE=100
         FAT_SIZE=50
       EXT_MARGIN=20
       FAT_MARGIN=5

     EXT4_OPTIONS="-m0 -i100000 -J size=32"
       EXT4_LABEL="LiveUSB"

          LIVE_MP="/live/boot-dev"
     LINUXFS_NAME="linuxfs"
 MIN_LINUXFS_SIZE="120M"
     DEF_BOOT_DIR="/antiX"

       CLONE_DIRS="boot EFI efi"
      CLONE_FILES="cdrom.ico version"
 CLONE_BDIR_FILES="{vmlinuz,vmlinuz1,initrd.gz,linuxfs}{,.md5}"

        GRUB_CONF="boot/grub/grub.cfg"
           CHEATS=""
        NO_CHEATS=""

         WORK_DIR="/run/$ME"
        LOCK_FILE="/run/lock/$ME"

        SHELL_LIB="cli-shell-utils.bash"
         LIB_PATH="/usr/local/lib/cli-shell-utils"
     COLOR_SCHEME="high"
        NO_CHEATS=""

#== END_CONFIG

   CONF_FILE="/root/.config/$ME/$ME.conf"
THE_LOG_FILE="/var/log/$ME.log"
THE_ERR_FILE="/var/log/$ME.errors"
    LOG_FILE=/dev/null
    ERR_FILE=/dev/null

ORDERED_CMDS="partition makefs makefs-ext makefs-fat copy copy-ext copy-fat"
ORDERED_CMDS="$ORDERED_CMDS uuids cheats cheats-syslinux cheats-grub install"
    ALL_CMDS="sizes all $ORDERED_CMDS"
    PRE_CMDS="partition makefs"
   POST_CMDS="uuids cheats install"

   ALL_FORCE="copy,flock,makefs,umount,usb"

       PATH="$MY_DIR:/usr/local/share/live-usb-maker/bin:$PATH"
  MENU_PATH="$MY_DIR/menus:/usr/local/share/text-menus/"
   MENU_DIR="$MY_DIR/menus"

usage() {
    local ret=${1:-0}

cat<<Usage
Usage: $ME [commands]

Create a live-usb from an iso-file, another live-usb, a live-cd/dvd
or a running live system.  You will be prompted for information that
is not supplied in the command line options.

Uses ext4 as the filesystem for the main live-usb partition and adds
a small fat32 file system for booting via UEFI.

This will destroy any existing information on <usb-device>.

  --from="iso-file"    get a menu of iso files
  --from="clone"       clone a running live system.
  --from=clone=<dir>   clone from a mounted live-usb or iso-file.
  --from=<dev>         copy from a livecd/dvd or live-usb

Options:
  -a --auto             Never ask questions.  Always assume the safe answer
  -c --cheat=xxx        Add these cheatcodes to the live-usb
     --color=<xxx>      Set color scheme to off|low|high
  -C --clear            Delete files from each partition before copying
  -d --device=<xxx>
  -D --debug            Pause before cleaning up
  -e --esp-size=<xx>    Size of ESP (fat) partition in MiB (default 50)
  -E --ext-options=<xx> Use these options when creating the ext4 filesystem

  -f --from=<xxx>       The device, cdrom, or file to make the live-usb from
                        Use "clone" to clone the current live system or use
                        clone=<xxx> to clone another live-usb

  -F --force=<xxxX>       Force the options specfied:
                            umount: Allows try to umount all partitions on drive
                               usb: Ignore usb/removable check
                            makefs: Make the ext4 filesystem even if one exists
                              copy: Overwrite ext4 partition even if antiX/ exists
                               all: All of the above (dangerous!)

  -g --gpt              Use gpt partitioning instead of msdos
  -h --help             Show this usage
  -i --ignore-config    Ignore the config file
  -L --label=Name       Label ext partition with Name
  -n --no-cheats        Don't show menus for adding cheat codes
  -p --pretend          Don't run most commands
  -q --quiet            Print less
  -s --size=XX          Percent of usb-device to use in (default 100)
  -v --verbose          Print more, show commands when run
  -w --write-config     Write a fresh config file

Notes:
  - short options stack. Example: -Ff instead of -F -f
  - options can be intermingled with commands and parameters
  - config file: $CONF_FILE
  - the config file will be sourced if it exists
  - it will be created if it doesn't exist
Usage
    exit $ret
}

eval_early_argument() {
    case $1 in
      -ignore-config|I) IGNORE_CONF=true                   ;;
       -write-config|W) IGNORE_CONF=true ; WRITE_CONF=true ;;
               -help|h) usage                              ;;
    esac
}

eval_argument() {
    local arg=$1  val=$2
        case $arg in
             -cheat|c)  CHEATS="$CHEATS${CHEATS:+ }$val" ;;
             -cheat=*)  CHEATS="$CHEATS${CHEATS:+ }$val" ;;
             -clear|C)  CLEAR=true                       ;;
               -color)  COLOR_SCHEME=$val                ;;
             -color=*)  COLOR_SCHEME=$val                ;;
             -debug|D)  DEBUG=true                       ;;
            -device|d)  TARGET=$val                      ;;
            -device=*)  TARGET=$val                      ;;
          -esp-size|e)  FAT_SIZE=$val                    ;;
       -ext-options|E)  EXT4_OPTIONS=$val                ;;
       -ext-options=*)  EXT4_OPTIONS=$val                ;;
          -esp-size=*)  FAT_SIZE=$val                    ;;
              -from|f)  FROM=$val                        ;;
              -from=*)  FROM=$val                        ;;
             -force|F)  FORCE="$FORCE,$val"              ;;
             -force=*)  FORCE="$FORCE,$val"              ;;
               -gpt|g)  MBR_GPT="gpt"                    ;;
             -label|L)  EXT4_LABEL=$val                  ;;
             -label=*)  EXT4_LABEL=$val                  ;;
         -no-cheats|n)  NO_CHEATS=true                   ;;
           -pretend|p)  PRETEND_MODE=true                ;;
             -quiet|q)  QUIET=true                       ;;
              -size|s)  SIZE=${val%\%}                   ;;
              -size=*)  SIZE=${val%\%}                   ;;
           -verbose|v)  BE_VERBOSE=true                  ;;

       # These are read early.  They are not unknown
     -ignore-config|I)                                   ;;
      -write-config|W)                                   ;;

               *)  fatal $"Unknown parameter %s" "-$arg" ;;
    esac
}

assign_parameter() {
    local cnt=$1 param=$2
   case $cnt in
        *) CMDS="$CMDS $param" ;;
    esac
}

takes_param() {
    case $1 in
       -cheat|c) return 0 ;;
      -device|d) return 0 ;;
    -esp-size|e) return 0 ;;
        -from|f) return 0 ;;
       -force|F) return 0 ;;
       -label|L) return 0 ;;
        -size|s) return 0 ;;
    esac
    return 1
}

main() {
    local SHIFT SHORT_STACK="cCdDeEfFghILnpqsvW"
    local BE_VERBOSE FROM TARGET FATAL_QUESTION CMD PARAM_CNT

    set_colors

    local orig_args="$*"
    local START_T=$(date +%s)

    [ $# -eq 0 ] && usage

    # Let non-root users get usage.  Need to get --ignore-config early.
    read_early_params "$@"

    need_root

    ERR_FILE=$THE_ERR_FILE

    trap clean_up EXIT

    do_flock $LOCK_FILE $ME

    rm -f $ERR_FILE

    if [ -z "$IGNORE_CONF" ]; then
        test -r "$CONF_FILE" && . "$CONF_FILE"
        test -e "$CONF_FILE" || write_conf "$CONF_FILE"
    fi

    read_all_cmdline_mingled "$@"
    set_colors $COLOR_SCHEME
    check_cmds  CMDS  "$ALL_CMDS" "$ORDERED_CMDS"
    check_force FORCE "$ALL_FORCE"

    case $SIZE in
        [1-9]|[0-9][0-9]|100) ;;
        *) fatal $"Bad size format '%s'.  Should be between %s and %s inclusive." "$(pqh $SIZE)" 1 100
    esac

    [ -z "${FAT_SIZE##[0-9]}" ] && fatal $"esp-size must be larger than %s" 9
    echo $FAT_SIZE | egrep -q "^[1-9][0-9]+$" || fatal $"esp-size must be an integer larger than %s" 9

    # Always write a new config file and then exit if requested
    if [ "$WRITE_CONF" ]; then
        write_conf "$CONF_FILE"
        exit 0
    fi

    [ "$PRETEND_MODE" ] && shout $"PRETEND MODE ENABLED"

    local we_are_live live_dev
    if its_alive; then
        we_are_live=true
        # FIXME: should use initrd.out to get the uuid, etc
        live_dev=$(get_live_dev)
        fatal_z "$live_dev" "Could not find the live boot device"
    fi

    [ ${#FROM} -eq 0 ] && select_usb_src FROM

    local search_dirs
    if [ ${#FROM} -gt 0 -a -z "${FROM##*\**}" ]; then
        ISO_FILE_SPEC=$(basename "$FROM")
        local sdir=$(dirname "$FROM")
        [ ${#sdir} -gt 0  ] && search_dirs=$sdir
        local fmt="%30s: %s"
        msg "$fmt"  "ISO file wildcard"       "$(pq "$FROM")"
        msg "$fmt"  "Will search directories" "$(pq "$search_dirs")"
        msg "$fmt"  "For files matching"      "$(pq "$ISO_FILE_SPEC")"
        FROM="iso-file"
    fi

    if [ "$FROM" = "iso-file"  ]; then
        : ${search_dirs:=$(echo $SEARCH_DIRS | sed "s|%USER_HOME%|$(get_user_home)|")}
        cli_search_file FROM "$ISO_FILE_SPEC" "$search_dirs" "$SEARCH_DEPTH" "$MAX_FILES"
        test -f "$FROM" || fatal "Not a normal file %s" "$FROM"
        msg "Using file %s" "$(pq "$FROM")"
        check_md5 "$FROM"
    fi

    local from_dev
    [ -n "$FROM" -a -z "${FROM##clone=*}" ] && from_dev=${FROM#clone=}
    [ ${#TARGET} -eq 0 ] && select_target_device TARGET "$live_dev" "$from_dev"

    local usb_dev=$(expand_device $TARGET)
    [ ${#usb_dev} -gt 0 ] || fatal $"Could not find device %s" "$TARGET"

    [ ${#CHEATS} -eq 0  -a -z "$NO_CHEATS" ] && cheats_menus CHEATS
    #echo "CHEATS: $CHEATS" ; exit

    # We start logging right after we've expanded the target device
    start_log "$orig_args" "$CMDS" "$FROM" "$usb_dev"
    #echo "$CMDS" | egrep -q "(^| )pre( |$)"  && CMDS="$CMDS $PRE_CMDS"
    #echo "$CMDS" | egrep -q "(^| )post( |$)" && CMDS="$CMDS $POST_CMDS"

    mkdir -p $WORK_DIR || fatal $"Could not make a work directory under /tmp"
    mount -t tmpfs tmpfs $WORK_DIR || fatal $"Could not mount tmpfs at %s" $WORK_DIR

    test -e $usb_dev || fatal $"Device %s does not exist" $usb_dev
    test -b $usb_dev || fatal $"Device %s is not a block device" $usb_dev

    local dev_type=$(lsblk -no type --nodeps $usb_dev)
    [ "$dev_type" = "disk" ] || fatal $"Device %s is not a disk device" $usb_dev

    local ext_dev=$(get_partition $usb_dev 1)
    local fat_dev=$(get_partition $usb_dev 2)

    # fatal "The device %s does not seem to be usb or removeable."
    force usb || is_usb_or_removable $usb_dev || yes_NO_fatal "usb" \
        $"Do you want to use it anyway (dangerous)?" \
        $"Use %s to always ignore this warning"      \
        $"The device %s does not seem to be usb or removeable."  "$usb_dev"

    ISO_DIR=$WORK_DIR/iso
    EXT_DIR=$WORK_DIR/ext
    FAT_DIR=$WORK_DIR/fat
    MNT_DIR=$WORK_DIR/live-dev

    mkdir $ISO_DIR $EXT_DIR $FAT_DIR || fatal $"Could not make %s subdirectories" "$WORK_DIR"

    mount_iso "$FROM" $ISO_DIR || fatal $"Could not mount iso file %s" "$FROM"

    local iso_version version_file=$ISO_DIR/version
    if test -r $version_file && iso_version=$(cat $version_file 2>/dev/null) \
        && [ ${#iso_version} -gt 0 ]; then
        msg $"Distro: %s" "$(pq $iso_version)"
        msg
    fi

    local total_size=$(parted $usb_dev unit MiB print | sed -rn "s/^Disk.*: ([0-9]+)MiB$/\1/p")
    local mib_size=$((total_size * SIZE / 100 - 1))
    local ext_size=$((mib_size - FAT_SIZE))
    local ext_needed=$(du_size $ISO_DIR/*)
    local fat_needed=$(du_size $ISO_DIR/{boot,EFI,efi})
    local ext_extra=$((ext_size - ext_needed))
    local fat_extra=$((FAT_SIZE - fat_needed))

    local mem_fmt="%20s:$num_co %7s$m_co MiB"
    local available=$"available" needed=$"needed" extra=$"extra"
    msg "$mem_fmt" $"total usb size"     $total_size
    msg "$mem_fmt" $"requested usb size" $mib_size
    msg "$mem_fmt" "ext $available"      $ext_size
    msg "$mem_fmt" "ext $needed"         $ext_needed
    msg "$mem_fmt" "ext $extra"          $ext_extra
    msg "$mem_fmt" "fat $available"      $FAT_SIZE
    msg "$mem_fmt" "fat $needed"         $fat_needed
    msg "$mem_fmt" "fat $extra"          $fat_extra

    YES_no_pretend || my_exit

    : ${CMNDS:=all}

    if [ ${#CMDS} -le 0 ]; then
        echo -e $"No command(s) given.  Try 'all'."
        my_exit 0
    fi

    check_size ext $ext_extra $EXT_MARGIN
    check_size fat $fat_extra $FAT_MARGIN

    given_cmd sizes && my_exit 0

    umount_all $usb_dev

    need partition && do_partition "$usb_dev" "$MBR_GPT" $ext_size $mib_size

    need makefs-ext && do_makefs_ext "$ext_dev" "$EXT4_OPTIONS" "$EXT4_LABEL"
    need makefs-fat && do_makefs_fat $fat_dev

    my_mount $ext_dev $EXT_DIR
    my_mount $fat_dev $FAT_DIR

    if [ "$QUIET" ]; then
        (echo; df -Tm $EXT_DIR $FAT_DIR; echo) >> $LOG_FILE
    else
        (echo; df -Tm $EXT_DIR $FAT_DIR; echo) | tee -a $LOG_FILE
    fi

    need copy-ext && do_copy_ext $ISO_DIR $EXT_DIR
    need copy-fat && do_copy_fat $ISO_DIR $FAT_DIR

    local ext_uuid=$(lsblk -no uuid $ext_dev)
    local fat_uuid=$(lsblk -no uuid $fat_dev)

    need uuids   && do_uuids $EXT_DIR "$ext_uuid" "$FAT_DIR/$GRUB_CONF" "$fat_uuid"

    [ ${#CHEATS} -gt 0 ] && need cheats-syslinux && do_cheats_syslinux $EXT_DIR "$CHEATS"
    [ ${#CHEATS} -gt 0 ] && need cheats-grub     && do_cheats_grub     $FAT_DIR "$CHEATS"

    need install && do_install $usb_dev $EXT_DIR $MBR_GPT

    my_exit 0
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
select_usb_src() {
    local var=$1  live_dev=$2
    local title=$"Please select the source of the new live-usb"
    local menu=$(cli_live_usb_src_menu "$live_dev")
    my_select_quit "$var" "$title" "$menu"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
select_target_device() {
    local var=$1  live_dev=$2  from_dev=$3
    local menu=$(cli_drive_menu "$live_dev" "$from_dev")
    local dev cnt=$(count_lines "$menu")
    case $cnt in
        0) fatal $"No usb drives found to create a live-usb on" ;;
        1) dev=$(echo "$menu" | cut -d"$P_IFS" -f1 | head -n1)
            Msg "Only one usb device was found: %s" "$(echo $(echo "$menu" | cut -d"$P_IFS" -f2))"
           eval $var=\$dev
           return ;;
    esac
    my_select_quit $var "Please select the target usb device" "$menu"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
cheats_menus() {
    local var=$1
    local tz_cheat cheats
    cli_text_menu cheats lang "Select default Language for the live-usb" \
        "Language implies timezone and other things"

    local blurb=$(printf "Timezones are listed by longitude. %s denotes daylight savings time" "$(pqq "*")")
    cli_text_menu tz_cheat tz "Select Default Timezone for the live-usb" "$blurb"

    [ "$tz_cheat" ] && cheats="$cheats${cheats:+ }$tz_cheat"
    eval $var=\$cheats
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
mount_iso() {
    local file=$1  dir=$2
    mkdir -p $dir

    is_mountpoint $dir && fatal $"Directory '%s' is already a mountpoint" $dir

    case $file in
        clone) mount_live $dir              ; return ;;
      clone=*) mount_live $dir "${file#*=}" ; return ;;
    esac

    local block_dev=$(expand_device $file)
    file=${block_dev:-$file}

    if test -b $file; then
        mount -o ro "$file" $dir
        is_mountpoint $dir && return 0
    else
        test -e "$file" || fatal $"Could not find iso file %s" "$file"
        test -r "$file" || fatal $"Could not read iso file %s" "$file"

        local type
        for type in iso9660 udf; do
            mount -t $type -o loop,ro "$file" $dir 2>/dev/null
            is_mountpoint $dir && return 0
        done
    fi

    fatal $"Could not mount iso file %s" "$file"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
mount_live() {
    local targ_dir=$1  live_dir=${2:-$LIVE_MP}

    is_mountpoint "$targ_dir" && fatal $"Live directory '%s' is already a mountpoint" "$targ_dir"

    # Allow live "directory" to be a device that we mount
    local block_dev=$(expand_device $live_dir)
    if [ ${#block_dev} -gt 0 ];  then
        my_mkdir $MNT_DIR
        mount -o ro $block_dev $MNT_DIR
        is_mountpoint $MNT_DIR || fatal $"Could not mount device %s" "$block_dev"
        live_dir=$MNT_DIR
    fi

    test -d "$live_dir"       || fatal $"Live directory '%s' is not a directory"   "$live_dir"
    is_mountpoint "$live_dir" || fatal $"Live directory '%s' is not a mountpoint"  "$live_dir"

    mount -t tmpfs tmpfs $targ_dir

    # FIXME: should the error message have a device, not a directory?
    local boot_dir
    find_live_boot_dir boot_dir "$live_dir" "$LINUXFS_NAME" \
        || fatal $"No '%s' ifle found in any directory on clone device at '%s'" "$LINUXFS_NAME" "$live_mp"

    msg "Live boot directory %s" "$(pq $boot_dir)"

    local full_boot_dir="$live_dir/${boot_dir#/}"
    local src_root_dir=$live_dir

    if [ -z "${boot_dir##*Frugal*}" ]; then
        msg "Cloning from a frugal directory"
        src_root_dir=$full_boot_dir
    fi

    # NOTE:
    # the cd && eval "ls ..." allows us to use globbing expansions with spaces in paths

    local dir from dest
    while read dir; do
        [ ${#dir} -gt 0 ] || continue
        from="$src_root_dir/$dir"
        dest="$targ_dir/$dir"
        test -d "$from" || continue
        mkdir -p "$dest" || fatal $"Could not create directory %s" "$dest"
        mount --bind "$from" "$dest"
    done <<Clone_Dirs
$(cd "$src_root_dir" && eval "ls -d $CLONE_DIRS" 2>/dev/null)
Clone_Dirs

    local file
    while read file; do
        [ ${#file} -gt 0 ] || continue
        from="$src_root_dir/$file"
        dest="$targ_dir/$file"
        test -f "$from" || continue
        mkdir -p "$(dirname "$dest")" || fatal $"Could not mkdir %s" "$(dirname "$dest")"
        touch "$dest"                 || fatal $"Could not touch file %s" "$dest"
        mount --bind "$from" "$dest"
    done <<Clone_Files
$(cd "$src_root_dir" && eval "ls -d $CLONE_FILES" 2>/dev/null)
Clone_Files

    while read file; do
        [ ${#file} -gt 0 ] || continue
        from="$full_boot_dir/$file"
        dest="$targ_dir/${DEF_BOOT_DIR#/}/$file"

        test -f "$from" || continue
        mkdir -p "$(dirname "$dest")" || fatal $"Could not mkdir %s" "$(dirname "$dest")"
        touch "$dest"                 || fatal $"Could not touch file %s" "$dest"
        mount --bind "$from" "$dest"
    done <<Clone_Bdir_Files
$(cd "$full_boot_dir" && eval "ls -d $CLONE_BDIR_FILES" 2>/dev/null)
Clone_Bdir_Files
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_partition() {
    local drive=$1  type=${2:-msdos}  ext_size=$3  mib_size=$4

    local boot_flag
    case $type in
          gpt) boot_flag=legacy_boot ;;
        msdos) boot_flag=boot        ;;
            *) fatal $"Unknown partitioning scheme: %s.  Expected msdos or gpt" "$type"
               ;;
    esac

    msg $"Using %s partitioning" $(pq $type)

    cmd parted --script --align optimal $usb_dev   \
        unit MiB                                   \
        mklabel $type                              \
        mkpart primary ext4  1         $ext_size   \
        mkpart primary fat32 $ext_size $mib_size   \
        set 1 $boot_flag on                        \
        set 2 esp  on || fatal $"Partitioning failed"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_makefs_ext() {
    local dev=$1  options=$2  label=$3  force_ext

    force makefs && force_ext="-F"
    cmd mkfs.ext4 $force_ext $options -L "$label" $dev \
        || fatal "makefs" $"Could not make %s file system on %s.  Perhaps try %s" "ext4" $ext_dev "--force=makefs"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_makefs_fat() {
    local fat_dev=$1
    cmd mkfs.fat -n "LIVE-ESP" $fat_dev \
        || fatal $"Could not make %s file system on %s" "fat32" "$fat_dev"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_copy_ext() {
    local iso_dir=$1  ext_dir=$2

    [ "$CLEAR" ] && cmd rm -rf $ext_dir/*

    if test -d $ext_dir/antiX && ! force copy; then
        warn $"Not over-writing %s partition due to existing %s directory" ext antiX/
        warn $"Use %s to overwrite" "--force=copy"
        return
    fi
    msg $"Copying files ..."
    cmd cp -a $iso_dir/* $ext_dir/ || fatal $"Error when copying files to live usb"
    sync
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_copy_fat() {
    local iso_dir=$1  fat_dir=$2

    [ "$CLEAR" ] && cmd rm -rf $fat_dir/* 2>/dev/null

    local top
    for top in $iso_dir/{efi,EFI,boot}; do
        test -e $top || continue
        cmd cp -r $top $fat_dir/ \
            || warn $"Error when copying %s files to fat partition" "$(basename $top)"
    done
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_cheats_syslinux() {
    #warn "Cheats are still being worked on"; return

    local ext_dir=$1  cheats=$2
    local syslinux_cfg=$ext_dir/boot/syslinux/syslinux.cfg

    require cheats-syslinux gfxsave || return

    local file params
    local verbose=1
    [ "$BE_VERBOSE" ] && verbose=6
    if test -w $syslinux_cfg; then
        params=$(sed -nr "1,/^\s*APPEND\s/s/^\s*APPEND\s+//p" $syslinux_cfg)
        Msg "syslinux params: %s" "$(pq $params $cheats)"
        VERBOSE=$verbose CMDLINE="$params $cheats" cmd gfxsave $ext_dir/boot both
    else
        warn $"Could not find %s file to update" "$(basename $syslinux_cfg)"
    fi
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_cheats_grub() {
    #warn "Cheats are still being worked on"; return
    local fat_dir=$1  cheats=$2
    local grub_cfg=$fat_dir/boot/grub/grub.cfg

    require cheats-grub vmlinuz-version grub2-save || return

    local params

    if test -w $grub_cfg; then
        params=$(sed -nr "1,/^\s*linux\s/s/^\s*linux\s+[^ ]+//p" $grub_cfg)
        Msg "grub params: %s" "$(pq $params $cheats)"
        cmd grub2-save $fat_dir --no-kernel --cheats="${params% } $cheats"
    else
        warn $"Could not find %s file to update" $(basename $grub_cfg)
    fi
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_uuids() {
    local ext_dir=$1  ext_uuid=$2  grub_cfg=$3  fat_uuid=$4
    if [ ${#fat_uuid} -gt 0 ]; then
        local fat_file=$ext_dir/antiX/esp-uuid
        cmd mkdir -p $(dirname $fat_file) || fatal $"Making directory %s failed" "$(dirname $fat_file)"
        cmd write_file $fat_file $fat_uuid
    else
        warn $"No %s given for %s partition" UUID fat
    fi

    if [ ${#ext_uuid} -eq 0 ]; then
        warn $"No %s give for %s partition" UUID ext4
        return
    fi

    if ! test -e $grub_cfg; then
        warn $"Could not find %s file" "$(basename $grub_cfg)"
        return
    fi

    local new_line="search --no-floppy --set=root --fs-uuid $ext_uuid"
    if grep -q "search.*--set=root.*" $grub_cfg; then
        # Replace the line(s) if it/they exists
        cmd sed -i "/search.*--set=root.*/  s/.*/$new_line/" $grub_cfg \
            || fatal "sed on %s failed" "$(basename $grub_cfg)"
    else
        # Add the new line before the first menuentry line if not
        cmd sed -ri "1,/^\s*menuentry/s/(^\s*menuentry)/$new_line\n\n\1/" $grub_cfg \
            || fatal "sed on %s failed" "$(basename $grub_cfg)"
    fi
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_install() {
    local usb_dev=$1  ext_dir=$2  type=$3

    local fname
    case $type in
          gpt) fname=gptmbr.bin ;;
        msdos) fname=mbr.bin    ;;
            *) fatal $"Unknown partitioning scheme: %s.  Expected msdos or gpt" "$type"
               ;;
    esac

    local dir file d
    for dir in /usr/share/syslinux /usr/lib/syslinux/mbr; do
        test -e $dir/$fname || continue
        file=$dir/$fname
        break
    done

    [ "$file" ] || fatal $"Could not find file %s" "$fname"
    cmd dd bs=440 conv=notrunc count=1 if=$file of=$usb_dev > /dev/null || fatal $"%s command failed" dd

    local sdir idir syslinux_dir isolinux_dir
    for sdir in boot/syslinux syslinux; do
        test -d $ext_dir/$sdir || continue
        syslinux_dir=$ext_dir/$sdir
        break
    done
    if [ -z "$syslinux_dir" ]; then
        for idir in boot/isolinux isolinux; do
            test -d $ext_dir/$idir || continue

            warn $"Create syslinux directory from %s" $idir
            syslinux_dir=$ext_dir/${idir%isolinux}syslinux
            cmd cp -r $ext_dir/$idir $syslinux_dir || fatal $"Could not copy the isolinux directory"
            local f
            for f in $(cd $syslinux_dir && ls isolinux.*); do
                test -e $ext_dir/$sdir/$f || continue
                cmd mv $ext_dir/$sdir/$f $ext_dir/$sdir/syslinux${f#isolinux}
            done
            break
        done
    fi
    [ "$syslinux_dir" ] || fatal $"Could not find a syslinux or isolinux directory"
    cmd extlinux -i $syslinux_dir || fatal "%s command failed" extlinux
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
check_size() {
    local type=$1  extra=$2  margin=$3
    [ $extra -lt 0 ] && fatal $"Not enough space on %s partition" "$type"
    [ $extra -lt $margin ] && fatal $"Less than %s MiB would remain on %s partition" "$margin" "$type"
}

my_exit() {
    local ret=${1:-0}

    show_elapsed

    if [ "$DEBUG" ]; then
        echo -n "${green}Press <Enter>$nc_co "
        read x
    fi

    Msg "=> cleaning up"
    exit $ret
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
start_log() {
    local args=$1 cmds=${2# } iso=$3 dev=$4

    LOG_FILE=$THE_LOG_FILE

    cat <<Start_Log >> $LOG_FILE
---------------------------------------------------------------------
$ME
    started: $(date)
comand line: $args
  found lib: $FOUND_LIB
   commands: $cmds
   iso file: $iso
     target: $dev
     cheats: $CHEATS

Start_Log
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
umount_work_dir() {
    local dir=${1:-$WORK_DIR}
    [ -n "$dir" ] || return

    sync; sync
    is_mountpoint "$dir" || return 0

    local try
    for try in $(seq 1 30); do
        umount --recursive "$dir"
        is_mountpoint "$dir" || return 0
        sleep .1
    done
    rmdir "$dir"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
clean_up() {
    umount_work_dir
    test -d $WORK_DIR && rmdir $WORK_DIR
    rm -f $LOCK_FILE
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
load_lib() {
    local file=$1 path=$2
    shift

    unset FOUND_LIB
    local dir lib found orig_ifs=$IFS
    IFS=:
    for dir in $path; do
        lib=$dir/$file
        test -r $lib || continue
        if ! . $lib; then
            printf "Error when loading library %s\n" "$lib" >&2
            printf "This is a fatal error\n" >&2
            exit 15
        fi
        FOUND_LIB=$lib
        IFS=$orig_ifs
        return 0
    done

    printf "Could not find library '%s' on path '%s'\n" "$file" "$path" >&2
    printf "This is a fatal error\n" >&2
    exit 17
}

#===== Start Here =============================================================
LIB_PATH="$LIB_PATH:$MY_DIR/../cli-shell-utils:$MY_DIR"
load_lib "$SHELL_LIB" "$LIB_PATH"

main "$@"

